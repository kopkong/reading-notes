函数
===

### 8.1 函数定义

```
A(123);

function A(a){
    console.log(a);
}
```

这是一条函数声明语句，声明会被提前。所以提前调用A()是能够输出结果的。

```
B(111);

var B = function(b){
    console.log(b);
}
```

这是以表达式方式定义的函数，B的声明被提前了，但是赋值并没有。所以提前调用B()会出错。

### 8.2 函数调用

如果方法不需要返回值时，最好直接返回this。这样就可以采用"链式条用"风格的编程。 `shape.setSize(100).setX(50).setY(50)`。

如果调用函数之前有关键词new，它就构成了构造函数调用。

* 构造函数会创建一个新的对象，当函数执行完毕如果它会显式返回。
* 如果构造函数使用return返回了一个对象，那么条用表达式的值就是这个对象。
* 如果构造函数返回了一个原始值或者return没有返回任何对象，这个值会被忽略。

### 8.5 作为命名空间的函数

```
(function myModule() {
    // 模块代码
    // 这个模块所使用的所有变量都是局部变量
    // 而不是污染全局命名空间
})();
```

### 8.6 闭包
和其他大多数现代编程语言一样，JavaScript也采用词法作用域。函数的执行依赖于变量作用域，这个作用域是在函数定义时决定，而不是在函数运行时决定的。函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为"闭包"。

```
function constfuncs() {
    var funcs = [];
    for(var i = 0; i < 10; i++){
        funcs[i] = function() { return i;}
    }
    return funcs;
}

var funcs = constfuncs();
console.log(funcs[5]());
```

上面这段最终会输出10。原因是所有的funcs共享一个变量i，而当constfuncs() 函数返回的时候i已经变成了10。关联到闭包的作用域链都是"活动的"。嵌套的函数不会将作用域内的私有成员复制一份，也不会对所绑定的变量生成静态快照。

### 8.7 函数属性、方法和构造函数

* arguments.length 表示传入函数的实参个数，而函数本身的length属性代表形参的个数。
* 每个函数都有prototype属性，它指向一个对象的引用。当函数用作构造函数的时候，新创建的对象会从原型对象继承属性。
* bind方法是ES5中新增的方法。作用主要是将某个函数绑定到某个对象上。
* Function构造函数允许JavaScript在运行时动态地创建并编译函数。但是它并不是使用词法作用域，函数体代码编译总是会在顶层函数执行。

```
var scope = "global";
function consFunction(){
    var scope = "local";
    return new Function("return scope"); // 无法在这里捕获局部作用域
}
consFunction()(); // 这里返回的是global
```

可以将Function()构造函数认为是在全局作用域中执行的eval()。

### 8.8 函数式编程



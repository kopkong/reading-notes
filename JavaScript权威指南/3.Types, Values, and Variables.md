类型、值和变量
=======

### 3.1 数字
JavaScript采用IEEE 754标准定义的64位浮点格式表示数字（这个和C++/Java 等语言里的double类型是一样的）。JavaScript中实际的操作（比如数组索引）则是基于32位整数。

* 全局变量 Infinity和NaN用来表示无穷大和非数字值。被0整数会返回 Infinity 或 -Infinity。
* NaN 无法和自身比较，`NaN == NaN` 返回的是false。所以要用 `isNaN` 函数来比较。
* JavaScript采用了二进制表示法，并不能精确地表示类似.1 这样的数字。所以 `.3 - .2 === .1` 返回值是false。如果可能的话尽量把小数转换成整数再做比较。

### 3.2 文本
JavaScript采用UTF-16编码的字符集。所以 `"𠮷".length === 2` 而 `"吉".length === 1`。

### 3.4 null和undefined
* 执行 `typeof null` 会返回 `object`。
* null和undefined都不包含任何属性和方法。使用`. []`操作符都会产生一个类型错误。


### 3.6 包装对象
存取字符串、数字、或布尔值的属性时创建的临时对象称作包装对象。
JS中的原始数据类型比如 `number, string, bool` 等，如果直接用 `.` 操作符给他们设置属性是无效的。 比如下面这段代码输出的结果是 `undefined`。
```
var s = '123';
s.len = 3;
console.log(s.len);
```

由于数值、字符串、布尔值的属性都是只读的，并且无法给他们定义新的属性。所以对 `s.len` 设置的任何值都是无效的。但是可以通过 Number(), String(), Boolean() 构造函数显式创建包装对象。
需要注意的是 `typeof new Number(1)` 是 `object` 而不是 `number`，当使用 `===` 操作符做比较它们和原始类型对象时会返回 `false`。

### 3.7 不可变的原始值和可变的对象引用
JavaScript 中的原始值 `undefined, null, bool, number, string` 与 对象（包括数组和函数）有着根本区别。通常将对象称为引用类型，而原始值也就是基本类型。当比较两个对象时，基本类型对值比较，而引用类型比较的是引用。（我的理解可能就是比较的原始数据指针地址）
所以即便两个长度一致，内容也完全一样的数组在比较时也是不相等的。 `[1,2] == [1,2]` 的返回值为 `false` 。

### 3.8 类型转换
下面是一些基础数据类型的类型装换规则

* null ==> "null" ==> 0 ==> false
* undefined ==> "undefined" ==> NaN ==> false
* Infinity ==> "Infinity" ==> Infinity ==> true
* 空数组[] ==> "" ==> 0 ==> true
* 一个数字元素的数组 [1] ==> "1" ==> 1 ==> true

当需要使用布尔值判断时，比如在if语句内。所有的对象（包括数组和函数）都转换为true。`new Boolean(false)` 也同样是true。对象到字符串和对象到数字的转换是通过 `toString 和 valueOf` 这两个方法来完成的。
一般的对象直接调用 toString() 会返回 `"[object Object]"`，而像Array，Date等特殊对象有自己定义的字符串转换方法。

JavaScript中对象到字符串的转换经过了如下这些步骤：
* 如果有toString()方法，则调用toString()方法。如果它返回一个原始值，JavaScript将这个原始值转化为字符串并返回。
* 如果对象没有toString()方法，或者这个方法不返回原始值，那么就会调用valueOf()方法。如果返回值是原始值JavaScript就将这个值转换为字符串并返回。
* 否则的话JavaScript无法从toString()或者valueOf()获得一个原始值，他将抛出一个类型错误异常。

JavaScript中对象到数字的转换也是类似的步骤，只不过第一步它会先调用valueOf()。

### 3.9 变量声明
在非严格模式下，试图给一个没有声明的变量赋值会给全局对象创建一个同名属性，这是一个很不好的习惯而且可能造成不易察觉的bug。

### 3.10 变量作用域
如果在函数内声明的一个局部变量或者函数参数中带有变量和全局变量重名，那么全局变量就会被局部变量所遮盖。
在ES5中JavaScript没有块级作用域，取而代之使用了函数作用域。在函数体内部任何地方声明的变量在整个函数作用域内都是可以访问的。这个特性也叫做声明提前，所以在写JavaScript代码时把所以变量定义都写在函数开始的地方是有重要意义的。

每一段JavaScript代码都有一个与之关联的作用域链（scope chain）。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码作用域中的变量。当JavaScript需要查找变量x的值的时候（这个过程称作"变量解析"（variable resolution）），它会从链中的第一个对象开始查找，如果不存在则继续查找链上的下一个对象。如果整个链上都没找到任何一个对象含有属性x，那么就认为这段代码的作用域链上不存在x，并最终抛出一个错误异常。
当定义一个函数时，它是加上保存了一个作用域链。当调用这个函数时，它创建一个新的对象来储存它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数条用作用域的"链"。